* 使用各种性能分析工具：GOT、GPM、URP并整合
* 不同平台代码库公用方案（前后端代码公用）
* UWorld, ULevel
* SortedArray
* QuadTree
* 二分图、二叉堆
* 消息系统：
	https://blog.csdn.net/qq_33413868/article/details/104725966  
	https://blog.csdn.net/qq_33413868/article/details/104725268  
	https://blog.csdn.net/qq_33413868/article/details/104721686
	https://blog.csdn.net/luoyikun/article/details/79442201
	https://www.jianshu.com/p/bf82beb41f7f
* 配表方案：https://blog.csdn.net/linshuhe1/article/details/52062969
* GPU Skinning: 
	https://github.com/chengkehan/GPUSkinning   
	https://github.com/Unity-Technologies/Animation-Instancing
	https://blogs.unity3d.com/2018/04/16/animation-instancing-instancing-for-skinnedmeshrenderer/
	https://www.cnblogs.com/smallrainf/p/11746909.html
	http://www.xuanyusong.com/archives/4488
* 也许用的到的工具
	asset-bundle-analyzer   https://github.com/faelenor/asset-bundle-analyzer   通过py脚本分析Bundles信息，并存储至SQLite
	DB Browser for SQLite 	https://sqlitebrowser.org/  SQLite查看工具
* Inspector Field for Scene Asset  https://answers.unity.com/questions/242794/inspector-field-for-scene-asset.html?_ga=2.221217361.81844548.1594053424-350901822.1561524296
* 监控所有的特效播放，统一特效加载接口
* 三维中物体的拖拽移动效果  https://www.cnblogs.com/springword/p/6683549.html
* FX_Root支持特效进入对象池时控制细节更精细，不是deactive GameObject，而是disable animation
* 设置抓帧调试环境
	1、Root设备
	2、安装magisk（再装一个propshide模块）
	3、改系统调试标记，如图
* Pool的初始大小可配置化
* Protobuf3优化
* 比较SQLite和Protobuf配表方案的异步（读取、缓存、导表）Openpyxl
* LUA配表优化  https://blog.uwa4d.com/archives/1490.html
* 高效场景管理工作流：https://mp.weixin.qq.com/s/U7T_3qTzFzrvOgPTNUIMFw
* 提高打包加速问题：https://mp.weixin.qq.com/s/sCgrrRXlYzXOPC1fKCX7UA
* sleep, pause（减少空转）, spin, 各种锁，map reduce
	线程的几种状态：new, runnable, running, not runnable, dead
	非可运行状态引申出三个状态：阻塞（blocked）、同步锁（locked）、等待（waiting）
* 互斥锁、自旋锁
	互斥锁：获取锁失败后线程进入睡眠或阻塞状态，这个过程会涉及到用户态到内核态的调度，上下文切换开销比较大
	自旋锁：用自旋来代替阻塞操作。获取某个锁失败，则此线程将不断循环检查该锁是否被释放，而不是让此线程挂起或睡眠，一种忙等待状态，过程中会一直消耗时间片
			需要保证各个本地缓存数据的一致性，在多处理器上，每个线程对应的处理器都对同一个变量进行读写。每次写操作都需要同步每个处理器缓存，这可能会影响性能。
	总结：互斥锁更适合持有锁时间长的情况，而自旋锁更适合持有锁时间短的情况
* 对象池重构：参照线程池7大核心参数
	corePoolSize（核心线程数）
	maximumPoolSize（最大线程数）：当项目比较多的时候，施工队就需要增加工人，但是也不能无限制地加。最多就加到 maximumPoolSize 个人，当闲下来的时候，施工队就要遣散工人，但是至少保留corePoolSize 个人。
	keepAliveTime&unit（存活时间&单位）：很简单，当线程池内部的线程数已经大于 corePoolSize 的时候，一个线程如果在一段时间内，都没有执行任务，说明很闲。keepAliveTime 和 unit 就是用来定义这个“一段时间”的参数。也就是说，如果一个线程空闲了keepAliveTime & unit 这么久，那么这个空闲的线程就要被回收了。
	handler（拒绝策略）：如果线程池中所有的线程都在忙碌，并且工作队列也满了（前提是工作队列是有界队列），那么此时提交任务，线程池就会拒绝接收。
	至于拒绝的策略，可以通过 handler 这个参数来指定：
		CallerRunsPolicy：提交任务的线程自己去执行该任务。
		AbortPolicy：默认的拒绝策略，直接丢弃任务，抛出RejectedExecutionException。
		DiscardPolicy：直接丢弃任务，没有任何异常抛出。
		DiscardOldestPolicy：丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列。
* 扩展FPS组件，捕获帧率突变
* Opt
	https://secretlab.institute/2019/06/14/power-saving-in-unity-for-non-game-apps/  Power-Saving in Unity
	https://gamedevelopertips.com/increase-performance-in-unity-games/  How To Optimise And Increase Performance In Unity Games
	https://blogs.unity3d.com/2019/04/01/higher-fidelity-and-smoother-frame-rates-with-adaptive-performance/  Higher fidelity and smoother frame rates with Adaptive Performance
	https://www.youtube.com/watch?v=KK2hWczq8ZY  Power Efficient Programing - Unite Europe 2015
	https://www.youtube.com/watch?v=j4YAY36xjwE  Unite Europe 2016 - Optimizing Mobile Applications
	https://www.youtube.com/watch?v=_wxitgdx-UI  Unite Europe 2017 - Squeezing Unity: Tips for raising performance
* JPS
	https://blog.csdn.net/yjxxtd/article/details/93506231
	https://blog.csdn.net/u011265162/article/details/91048927?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param
* BackgroundDownload
	https://github.com/Unity-Technologies/BackgroundDownload
* 如何优雅地接入外部插件（uwa），可定制什么时候发布
* 扩展Gesture——双击功能，贴边移动
* Package目录下shader如何打包？https://answer.uwa4d.com/question/5f3d10b19424416784ef1c82
* ACT技能编辑器的制作经验分享 https://blog.uwa4d.com/archives/USparkle_ACT.html
* 利用IJob优化DynamicBones https://mp.weixin.qq.com/s/WPURBQ8lyg9eCx2bITtKiw
* 配置方案：pb、flatbuffer、zeroformatter
	内存：随用随取，不用全部进内存
	加载：
* 网络库在android&ios上网络切换时的响应：4G & WIFI互相切换、网络彻底断开等
* OBB管理  https://stackoverflow.com/questions/25832334/i-have-mounted-my-obb-file-but-how-to-get-the-final-path-to-my-assets
		   https://answers.unity.com/questions/1228809/where-to-put-my-obb-file.html
* 对象池管理：常驻内存机制与预加载机制
* OBB管理：判断是分包方式还是整包方式，分包方式才需要下载obb
* bundle加密   https://www.xuanyusong.com/archives/4607
* 一种Shader变体收集打包以及编译优化的思路
	https://answer.uwa4d.com/question/5da86670e84db43d6efbda72
	https://mp.weixin.qq.com/s/9_Wl-cm-4ZF2lAl4FLnYxg
* RTS中的避障算法
	VO:
		https://blog.csdn.net/zhiai315/article/details/113931422  VO避障
		https://blog.csdn.net/natsu1211/article/details/37774547?spm=1001.2014.3001.5501  碰撞回避算法(一) Velocity Obstacle
	RVO:
		http://www.meltycriss.com/2017/01/13/paper-rvo/ 论文笔记《Reciprocal Velocity Obstacles for Real-Time Multi-Agent Navigation》
		https://zsummer.github.io/2019/06/08/2019-06-08-rvo/  RVO源码阅读笔记
		http://blog.sina.com.cn/s/blog_6ad33d350102xqal.html  RVO算法
		https://www.jianshu.com/p/8fc4e90e3850  RVO（Reciprocal Velocity Obstacles）障碍物规避算法
		https://github.com/anders007/RVO/blob/master/%E7%A2%B0%E6%92%9E%E8%A7%84%E9%81%BF%E7%AE%97%E6%B3%95RVO(Reciprocal%20Velocity%20Obstacles)%E7%AE%80%E4%BB%8B.pdf
	RVO2(ORCA):
		https://zhuanlan.zhihu.com/p/74888471  ORCA-有关机器人群碰撞避免算法解读
		https://blog.csdn.net/liuerin/article/details/103610440?spm=1001.2014.3001.5501  ORCA(Optimal Reciprocal Collision Avoidance)笔记
		https://blog.csdn.net/u012740992/article/details/89397714  导航动态避让算法RVO的优化ORCA
	Paper:
		https://gamma.cs.unc.edu/RVO/
 		https://gamma.cs.unc.edu/RVO2/
 		https://gamma.cs.unc.edu/ORCA/ 	
		http://www.red3d.com/cwr/boids
	Github:
		https://github.com/snape

* 寻路 	
	https://blog.csdn.net/needmorecode  NavMesh生成研究 && Recast源码解析	
 	https://cloud.tencent.com/developer/article/1502519  A*寻路初探
 	https://www.cnblogs.com/technology/archive/2011/05/26/2058842.html  理解A*寻路算法具体过程
 	https://blog.csdn.net/XieNaoban/article/details/53524165?spm=1001.2014.3001.5501  [笔记]A*寻路算法初探
	http://aigamedev.com/open/review/total-war-ai/		
	https://www.cnblogs.com/flyinggod/p/8671053.html  D*是动态A*，适合动态网格，环境如权重不断变化情况下
	https://blog.csdn.net/lqzdreamer/article/details/85055569  D*路径搜索算法原理解析及Python实现
	https://blog.csdn.net/banzhuan133/article/details/100532206  D*(Dynamic A*) 算法详细解析	
	路径平滑算法：佛洛依德路径平滑算法（FLOYD）、漏斗算法


	https://zhuanlan.zhihu.com/p/109108400  RTS游戏中的寻路
	https://zhuanlan.zhihu.com/p/109556568 	
	https://blog.csdn.net/KubilityDef/article/details/79483414 
	https://www.gameres.com/340777.html  即时战略游戏中实用的寻路算法分享 
	https://www.zhihu.com/question/20298134  即时战略游戏中实用的寻路算法都有哪些，比较如何？
	https://blog.csdn.net/liweizhao/article/details/82106886  集群算法介绍
	https://blog.csdn.net/a1047120490/article/details/105108701  集群寻路问题的一些思考和提炼
	https://blog.csdn.net/needmorecode/article/details/82050409  寻路建模的三种方式比较
	https://www.shangmayuan.com/a/2cb9439dd987480b86c171d8.html  多边形寻路算法简单介绍
	https://www.cnblogs.com/neoragex2002/archive/2007/09/09/887556.html  Navigation Mesh与Line-of-Sight Test
	http://www.luzexi.com/2013/10/06/Unity3D%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1NavMesh%E5%AF%BB%E8%B7%AF  Unity3D架构设计NavMesh寻路  有代码
	https://zhuanlan.zhihu.com/p/40177186 NavMesh生成原理
	https://zhuanlan.zhihu.com/p/38053482 NavMesh导航寻路使用
	https://zhuanlan.zhihu.com/p/270363845  A星寻路和navmesh寻路的技巧和优化
	https://my.oschina.net/u/1859679/blog/1486636  深入理解游戏中寻路算法
	https://blog.csdn.net/qq_32270109/article/details/90673151?spm=1001.2014.3001.5501  RVO算法探究. 和AStarPathFinding插件研究
	https://zhuanlan.zhihu.com/p/355887068  Unity 实现各种寻路算法
	https://blog.csdn.net/q764424567/article/details/80528457?spm=1001.2014.3001.5501  Unity3d 寻路插件A*Pathfinding学习与研究
	https://zhuanlan.zhihu.com/p/108361733  寻路算法之A*算法 Unity项目实战 优化
	http://frankorz.com/2017/12/16/greedy-best-find-search/  寻路算法 - 贪婪最佳优先算法
	Flocking Behaviour
	Steering Behaviour


	
* Unity游戏性能优化之内存篇
	https://mp.weixin.qq.com/s/2VufiCiU7TT8rM9BK-CTZA
	https://mp.weixin.qq.com/s/LWTDjqEY2YbZHZeksrtBvA
	https://mp.weixin.qq.com/s/an36v8erNS7HKrh9HRylcQ
* Unity CommandBuffer或是Camera重定向RenderTarget的ColorBuffer & DepthBuffer
	https://blog.csdn.net/linjf520/article/details/104964803
* XLua开发环境的整合
	pbc
	luac
	lua profiler
	lua break ponit
	与C#共享内存 https://github.com/Tencent/xLua/issues/764			
	常用库的集成 https://github.com/chexiongsheng/build_xlua_with_libs
* UI框架功能划分
	图集
	DC可视化组件
	修改基础控件的默认参数
	HUD
	红点系统
	新手引导
* AOI
	https://mp.weixin.qq.com/s/3srAV6SOW4CCIN57mYDYng
	https://www.zhihu.com/question/43625409
	https://zhuanlan.zhihu.com/p/56114206
	https://blog.csdn.net/a374826954/article/details/17642587
	https://gameinstitute.qq.com/community/detail/108545
	https://blog.codingnow.com/2012/03/dev_note_13.html
	https://blog.codingnow.com/2008/07/aoi.html
	https://blog.codingnow.com/2008/11/aoi_server.html
	https://www.cnblogs.com/persistentsnail/p/3294842.html
	https://www.bookstack.cn/read/zinx/dadf967af9c153a4.md
	http://www.cppblog.com/jaxe/archive/2014/10/17/148998.html
* JPS
	https://www.cnblogs.com/KillerAery/p/12242445.html
	https://blog.csdn.net/u011265162/article/details/91048927
* Unity内置资源如何打包避免冗余
	https://mp.weixin.qq.com/s/thEI6NoyCrWnkrqF9Y346g
* 搭建特效制作环境（InGame、UI）
* 去除所有FX_Component组件上的duration，统一使用FX_Root duration
* 对象池管理特效：当特效数量达到一定值，使用LOD机制弱化效果(FX AUTOLOD)
* 特效优化：
    https://forum.unity.com/threads/released-off-screen-particles-render-particles-at-1-2-1-4-or-1-8-screen-resolution.358506/
    https://github.com/slipster216/OffScreenParticleRendering
    https://blogs.unity3d.com/2016/12/20/unitytips-particlesystem-performance-culling/
    https://blogs.unity3d.com/2016/04/20/particle-system-modules-faq/
* optimization tips:
    culling仅在系统可预测时生效
    打开单个模块不仅会增加开销，更可能因为从过程模式（可预测）切换到非过程模式（不可预测）增加了整个系统的开销
    通过脚本改变数值将不再culling
    哪些是可预测模式？
        Local space
    show bound：持续改变说明是不可预测模式
    减少脚本控制，尽量使用系统内置功能
	






- dll热更方案
	https://www.jianshu.com/p/ebb7a6080540  Unity Android Dll热更新使用说明
	https://juejin.cn/post/6844903713635581965   Unity Android il2cpp的完美热更解决方案
	https://www.yangzhenlin.com/unity-android-dll-hotupdate-encrypt/   Unity Android DLL 热更新与加密
	http://blog.sina.cn/dpool/blog/s/blog_9e5d42ee0102vvtg.html   Unity Android动态更新Assembly-CSharp.dll
	https://blog.csdn.net/u011643833/article/details/47261015   【Unity】代码加密（一）编译libmono
	https://www.jianshu.com/p/7b205ebcb54a  通过IL2CPP热更代码
- 使用反射实现类UE的Config.ini全局数据配置机制
- 重构loaderType，启动方式移至Launcher
- 发布release时仅发布第一个场景
- FileList记录基于文件的MD5和基于content的MD5
- Deployment涉及的文件夹一律小写
- PlatformName/FileList
- 封装BuildNumer的修改
- 测试batchmode模式打包
  重构：output可以动态设置
  "Assets/Temp/"
- SkipList
	https://blog.csdn.net/ict2014/article/details/17394259
	https://blog.csdn.net/kisimple/article/details/38706729
	https://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html
- 延迟队列
	https://mp.weixin.qq.com/s/A85ievNNzHDrQv67yBkbtA
- Heap && PriorityQueue
	https://www.toutiao.com/i6778731130720879118/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1602237827&app=news_article&utm_source=weixin&utm_medium=toutiao_android&use_new_style=1&req_id=20201009180346010012058046260C4B64&group_id=6778731130720879118
	https://stackoverflow.com/questions/102398/priority-queue-in-net
	https://www.dotnetlovers.com/article/231/priority-queue
	https://referencesource.microsoft.com/#PresentationCore/Shared/MS/Internal/PriorityQueue.cs,3779854732f36d06
- 排序算法： 
	https://mp.weixin.qq.com/s/DfrZHKh-QyKG_Af5H5LWGg  动画详解常用排序算法	
	https://www.toutiao.com/i6873663185333780999/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1602393817&app=news_article&utm_source=weixin&utm_medium=toutiao_android&use_new_style=1&req_id=2020101113233701001204321612436D8E&group_id=6873663185333780999	
	https://www.toutiao.com/i6879298784736576014/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1602237809&app=news_article&utm_source=weixin&utm_medium=toutiao_android&use_new_style=1&req_id=20201009180328010017087043020C3BC4&group_id=6879298784736576014	
	https://www.toutiao.com/i6829510116627186188/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1602237964&app=news_article&utm_source=weixin&utm_medium=toutiao_android&use_new_style=1&req_id=202010091806040100150441561E0C7FA4&group_id=6829510116627186188
- FPS组件   https://mp.weixin.qq.com/s/RtRxap4vnJIhY2SQ3KWHPQ
- Network
	https://codereview.stackexchange.com/questions/224185/asynchronous-circular-buffer-in-c
	C# + Socket断线重连 https://blog.csdn.net/Duke147/article/details/50833745?utm_medium=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v25-4.nonecase&depth_1-utm_source=distribute.pc_relevant_bbs_down.none-task--2~all~first_rank_v2~rank_v25-4.nonecase
	https://stackoverflow.com/questions/59381847/writting-a-efficient-circular-buffer-for-use-with-c-sharp-socket
	整合NetClient, NetManager
	切换至后台可以维持很长时间的连接，飞行模式则不能，但具体情况视平台而定。没有统一的处理断线方法
	OnApplicationFocus、OnApplicationPause
- unsafe和非托管内存优化（字符串）
- string intern优化  https://zhuanlan.zhihu.com/p/23877335?refer=gu-lu  https://www.cnblogs.com/liuqiyun/p/9446887.html
- ObjectPool整合进Framework
- 手势模块：
	* 悬停
	* MyStandalongInputModule添加自定义当前选中对象
	* 思考:如何在PC上实现Pinch，见ProcessUnusedMouseEventData
- SBP: IBuildParameters.UseCache = false;实现rebuild bundle功能
- SoftPath分别存储BundleName，AssetName，减少运行时字符串操作
- 完善日志系统
	https://www.jianshu.com/p/5163b0a0180e
- Gesture Extension
	https://stackoverflow.com/questions/40341191/pinch-and-other-multi-finger-gestures-in-modern-unity3d
	https://stackoverflow.com/questions/40576493/duplicating-unitys-mystic-interface-power/40576974#40576974
- 嵌套Prefab的使用规范总结
- 可视化图集引用关系
- 尝试其他图集管理方法
1、check ”include in build"
2、图集和散图打在相同AB包中
3、不需要监听spriteAtlasManager
4、替换散图AB能热更
- 提供子文件夹的bundle name与父文件夹保持一致的功能
- 整理命名空间，s_XXX
- 整理所有Clear接口，仅清空数据，仍可用
- 添加MonoLRU，可制作为prefab，可视化配置
- GetOrCreatePoolInst RemoveMonoPoolInst重构至PoolManager
- SoftObject增加对IPooledObject对象加载的支持
- 增强显示：SoftObjectAttribute
- 支持SceneAsset的redirector
- SoftObject添加延时加载功能
- build from script
- SpawnerRing使用AB，PoolManager方式重制
- 参考GameFramework设置目录结构
- 打包出现modified的问题
- 使用ResourceManager的标准用法重构SpawnRing
- 配置：所有缓存对象可配置化（初始化大小等）
  PrefabObjectPool支持可视化配置，非MonoPool暂不支持
- PoolManager可配置Pool   Pool = PoolManagerExtension.GetOrCreatePool<Decal, LivingPrefabObjectPool>(assetPath);
  不支持assetPath方式Pool静态配置，可以把PrefabObjectPool做成Prefab，然后动态加载
- 退出Play Mode时PoolManager数据清除干净
- LRU
- PrefabObjectPool.m_ActivedObjects无法优化，考虑加宏控制是否启用(还有一个思路：自定义BetterLinkedList)
-- PoolManager EditorWindow, stat memory info
- review ObjectPool inspector
- 隐藏IBetterLinkedListNode。Next的set接口
- LinkedObjectPool Testcase
- LinkedObjectPool
- BetterLinkedList
- PoolManager inspector
- review LivingPrefabObjectPool
- GetOrCreatePool(string assetPath)
- Pool支持可选是否DontDestroyOnLoad
- 工具监测特效制作是否规范
- 工具检测特效是否符合合批规范
https://github.com/gmhevinci/MotionFramework/blob/master/Docs/Editor.ParticleProfiler.md
https://github.com/sunbrando/ParticleEffectProfiler
- FX_Root配置回收类型（Destroy、IPool），可配置有哪些对象池可供选择
- 完善FX_Root，接入对象池* 去除所有FX_Component组件上的duration，统一使用FX_Root duration